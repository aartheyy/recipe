package com.example.demo.services;

import java.util.HashSet;
import java.util.List;
import java.util.Optional;
import java.util.Set;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import com.example.demo.converter.RecipeCommandToRecipe;
import com.example.demo.converter.RecipeToRecipeCommand;
import com.example.demo.entities.Ingredient;
import com.example.demo.entities.Recipe;
import com.example.demo.exception.NotFoundException;
import com.example.demo.form.CategoryCommand;
import com.example.demo.form.IngredientCommand;
import com.example.demo.form.RecipeCommand;
import com.example.demo.repositories.RecipeRepository;



@Service
public class RecipeServiceImpl implements RecipeService {

	private final RecipeRepository recipeRepository;
	private final CategoryService categoryService;
	private final RecipeCommandToRecipe recipeCommandToRecipe;
	private final RecipeToRecipeCommand recipeToRecipeCommand;

	private static final Logger log = LoggerFactory.getLogger(RecipeServiceImpl.class);

	public RecipeServiceImpl(RecipeRepository recipeRepository,
			CategoryService categoryService,
			RecipeCommandToRecipe recipeCommandToRecipe,
			RecipeToRecipeCommand recipeToRecipeCommand) {

		this.recipeRepository = recipeRepository;
		this.categoryService = categoryService;
		this.recipeCommandToRecipe = recipeCommandToRecipe;
		this.recipeToRecipeCommand = recipeToRecipeCommand;
	}

	@Override
	public Set<RecipeCommand> getRecipes() {
		Iterable<Recipe> recipeSet = new HashSet<>();
		Set<RecipeCommand> recipeCommandSet = new HashSet<>();
		recipeSet = recipeRepository.findAll();
		for (Recipe recipe : recipeSet) {
			recipeCommandSet.add(this.recipeToRecipeCommand.convert(recipe));
		}
		return recipeCommandSet;
	}

	@Override
	@Transactional
	public Recipe findById(long recipeId) {
		Optional<Recipe> recipeOpt = recipeRepository.findById(recipeId);
		if (! recipeOpt.isPresent()) {
			throw new NotFoundException("recipe not found");
		}
		return recipeOpt.get();
	}

	/**
	 * saveRecipe save a recipe in db
	 */
	@Override
	@Transactional
	public RecipeCommand saveCommandRecipe(RecipeCommand recipeCommand) {

		Recipe recipe = recipeCommandToRecipe.convert(recipeCommand);
		//remove empty ingredients
		Set<Ingredient> ingredients = new HashSet<>();
		//in ui we can add any empty ingredients so when we save we remove empty ingredients
		for (Ingredient ingredient : recipe.getIngredients()) {

			if (ingredient.getId() < 0) {
				//it's a new ingredient we had put a negative id in order to can remove it if user remove an unsaved ingredient
				// now we will save ingredient so we remove ingredient id because it must be auto generated by mysql
				ingredient.setId(null);
			}
			ingredients.add(ingredient);

		}
		recipe.setIngredients(ingredients);
		Recipe savedRecipe = recipeRepository.save(recipe);
		log.debug(String.format("Recipe id '{0}' is saved.", savedRecipe.getId()));

		RecipeCommand savedRecipeCommand = this.recipeToRecipeCommand.convert(savedRecipe);

		return savedRecipeCommand;
	}

	@Override
	@Transactional
	public RecipeCommand findRecipeCommandById(long recipeId) {

		Recipe recipe = this.findById(recipeId);
		RecipeCommand recipeCommand = this.recipeToRecipeCommand.convert(recipe);
		List<CategoryCommand>  commandCategories = this.categoryService.fillCommandCategories(recipeCommand.getCategories());
		recipeCommand.setCategories(commandCategories);

		return recipeCommand;
	}

	/**
	 * deleteById delete recipe in db
	 */
	@Override
	public void deleteById(long id) {
		this.recipeRepository.deleteById(id);
	}

	/**
	 * removeIngredient remove an ingredient to form only (not save in db)
	 */
	@Override
	@Transactional
	public RecipeCommand removeIngredient(RecipeCommand recipeCommand, long ingredientId) {

		IngredientCommand IngredientToRemove = null ;

		for (IngredientCommand ingredient : recipeCommand.getIngredients()) {
			if (ingredient.getId() == ingredientId) {
				IngredientToRemove = ingredient;
				break;
			}
		}
		//remove statement is out side the for each loop to escape ConcurrentModificationException
		if (null != IngredientToRemove) {
			recipeCommand.getIngredients().remove(IngredientToRemove);
		}

		//refill (checked and unchecked) categories
		recipeCommand.setCategories(this.categoryService.fillCommandCategories(recipeCommand.getCategories()));

		return recipeCommand;
	}

	/**
	 * addEmptyIngredient add ingredient to form only (not save in db)
	 */
	@Override
	public RecipeCommand addEmptyIngredientToForm(RecipeCommand recipeCommand) {

		//the new ingredient are not saved, we don't know what will do the user so we put an temporary negative id 
		//( id is needed to delete an ingredient
		IngredientCommand newIngredient = new IngredientCommand();
		long randomid = (long) (Math.floor(Math.random() * 9_999_999_999L) + 9_000_000_000L)*(-1);
		newIngredient.setId(randomid);
		recipeCommand.getIngredients().add(newIngredient);

		return recipeCommand;
	}


	/**
	 * return a RecipeCommand filled by categories from database
	 */
	@Override
	public RecipeCommand getEmptyRecipeCommandWithAllCategories() {
		RecipeCommand commandRecipe =new RecipeCommand();
		commandRecipe.setCategories(this.categoryService.findAllCategoryCommand());
		return commandRecipe;
	}

}
